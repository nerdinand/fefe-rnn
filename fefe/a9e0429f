[l] Unix-User unter euch kennen sicher diff und patch, und rsync.Wer ein diff und patch fuer Binaerdateien sucht, fuer den gibt es leider kein Standardtool. Es gibt da diverse Tools auf dem Markt, das bekannteste ist xdelta, aber es gibt auch bsdiff, BDelta, bdiff (lag mal auf Sourceforge herum, aber scheint verloren gegangen zu sein; ich hatte hier noch einen Tarball fuer Version 1.0.4 herumliegen), jptch/jdiff und sicher noch mehr, die ich nicht kenne.Mein Anwendungsfall war, dass ich hier ein ISO-Image einer Linux-Distribution aendere, und gerne davon wegkommen wollte, immer das ganze ISO uebertragen zu muessen. Und so ein ISO, das sind mal eben 4 GB oder so.Bei solchen Datenmengen trennt sich die Spreu vom Weizen. Ich nehme im Wesentlichen das unveraenderte ISO-Image und fuege ein paar Dateien dazu. Meine Erwartungshaltung war: Der Patch sollte 1 MB nicht ueberschreiten.xdelta roedert laenglich herum und erzeugt einen mehrere hundert MB grossen Patch (ich nehme das ISO und fuege ein paar Dateien dazu, wir reden hier von sowas wie 100 KB zusaetzlichen Dateien). Da brach ich ab.bsdiff versucht, die ganze Datei (mit read statt mmap!) in den Speicher zu lutschen und failed dabei, weil read() von 4 GB unter Linux nur 2 GB liefert. Ich weiss nicht, welcher Vollpfosten das bei Linux entschieden hat. In meinen Augen ist das ein Bug. War wahrscheinlich ein gut gemeintes Security-Theater oder so. bsdiff ist also auch ausgefallen.jojodiff roedelt anderthalb Minuten und erzeugt dann 1,3 MB. Geht doch!bdelta braucht 10 Sekunden (!?) und erzeugt einen Patch von 1,6 MB. Der funktioniert dann leider nicht. Wie sich rausstellt, ist das Dateiformat von bdelta hirnrissig und failed nicht wie im README dokumentiert ab 4 GB sondern schon vorher. Fuer das Abspeichern der relativen Offsets zwischen Quellen fuer Patches nimmt der 32-bit signed Integer, und prueft natuerlich auch nicht, ob der Wert, den er abspeichern will, auch passt. bdelta ist aber ansonsten ausgesprochen sympathisch, weil der Quellcode so winzig und unpraetentioes ist, und das Format so trivial. Also habe ich mal einen Patch gemacht, damit er die Integer mit variabler Laenge abspeichert (ich nehme dafuer das Verfahren von den Google Protocol Buffers, das ist ganz schlau wie ich finde). Das ganze Ding platzt wahrscheinlich immer noch bei Dateien ueber 4 GB, aber fuer meinen konkreten Anwendungsfall tut es ganz gut.Weil das Projekt soweit verlassen wirkt, tu ich den Patch mal auf meinen Webserver, falls das jemand braucht.Update: Ein langjaehriger Leser weist darauf hin, dass ich die Gruende fuer das 2 GB-Limit schon mal erklaert hatte. Mein Kumpel Erdgeist prueft das uebrigens gerade unter BSD, und zumindest OS X hat auch ein 2 GB-Limit, sogar dokumentiert bei readv.Update: Unter den freien BSDs hat read() auch ein 2GB-Limit. WTF!?Update: Einige Leser haben herausgefunden, dass man unter FreeBSD das 2GB-Limit mit den sysctls debug.devfs_iosize_max_clamp und debug.iosize_max_clamp abschalten kann.
