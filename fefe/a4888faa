[l] Gerade sind frisch eine neue Binutils-Version und eine neue glibc-Version rausgekommen, und gcc 8 scheint auch fast fertig zu sein. Eines der (aus meiner Sicht) wichtigsten Features von gcc 8 ist der Support fuer "static PIE". PIE steht fuer Position Independent Executables. Normalerweise sind Binaries (Programme) auf eine bestimmte Adresse im Speicher hin gebaut. Jeder Prozess hat einen virtuellen Adressraum, und in dem liegen Binaries standardmaessig bei 400000 und ihre Daten ab 600000. Das war historisch nie ein Problem und hat auch Vorteile, weil man dann naemlich im Maschinencode Dinge vereinfachen kann, weil man immer weiss, wo was ist.Auf der anderen Seite wissen dann auch Hacker, wo was ist. Und weil die Softwareentwicklungsbranche vor vielen Jahren entschieden hat, dass sauber Programmieren zu schwer ist und wir lieber Hacker aergern wollen, ging die Entwicklung dann dahin, dass man das Programm halt bei jedem Programmstart woanders hin tut im Adressraum. Das nennt sich dann PIE.Technisch laeuft das ueber einen gruseligen Hack im ELF-Dateiformat, denn das kennt nur Binary (Programm, an statischer Adresse) und Shared Object (Shared Library, an dynamischer Adresse). Das ist schlicht nicht vorgesehen, dass ein Programm an einer zufaelligen Adresse geladen wird. Selbst wenn man den Code so formuliert, dass das ginge (was bei Intel/AMD bei 64-bit-Programmen viel einfacher und effizienter geworden ist als bei 32-bit-Programmen, weil der Befehlssatz da ein anderer ist, der darauf ausgelegt ist). Kurz gesagt gibt es bei 64-bit-Programmen eigentlich keine Effizienz-Ausrede mehr, um die nicht positionsunabhaengig zu machen. Es gibt natuerlich, wenn man genau hinguckt, doch einen Performancenachteil, aber den will ich hier mal aussen vor lassen :-)Der Hack ist jetzt so, dass man in der Datei eintraegt, es sei eine Shared Library, kein Programm. Der Kernel laedt die trotzdem und alles ist gut. Das ist leider ein Opt-In-Ding. Wenn ihr unter Linux Software baut, tut mal bitte immer schoen -fPIE auf die Compiler-Kommandozeile.Nun bin ich aber nicht an regulaeren Binaries interessiert, sondern an statischen Binaries (das ist die Zielgruppe fuer meine libc). Und der Hack mit dem PIE geht zwar vom Dateiformat her auch bei statisch gelinkten Programmen, aber in der Praxis halt nicht. Ich habe mal ein paar Tage lang versucht, das doch zum Laufen zu kriegen, und bin am Ende gescheitert. Es geht aber prinzipiell. Das weiss ich, weil es jemand anderes geschafft hat: Der Autor der musl-libc. Der gute Mann hat irgendwann bei GNU ein paar Bugs eingetragen, ob es nicht toll waere, wenn man da nicht so gruselig hacken muesste, wie er es getan hat. Und gcc 8 hat jetzt die Option -static-pie, die genau das tun soll.Die wollte ich also auch direkt mal ausprobieren, und baute erstmal die neuen binutils, dann den neuen gcc, und jetzt die neue glibc. Und dann fiel mir auf, dass ploetzlich meine dietlibc-Binaries groesser waren. /bin/true macht im Wesentlichen nichts und sollte eigentlich nur ein paar Bytes gross sein (ein paar ELF-Header brauchen Binaries schon, aber so Groessenordnung 200 Bytes ist eigentlich realistisch). War es aber nicht, sondern es war ploetzlich ueber 4k gross. Gut, es war auch vorher weit davon entfernt, weil die dietlibc inzwischen eben eine Menge anderen Kram supportet, der die Startup-Code groesser macht. Z.B. den Stack Protector initialisieren, und Thread Local Storage. Aber das true-Binary haette trotzdem deutlich unter 4k sein muessen.Ich habe also ein bisschen rumgeguckt, und es stellte sich raus, dass das nur mit dem binutils-bfd-ld so war. binutils ist das Paket unter Linux, aus dem der Assembler und der Linker kommen. binutils hat aber zwei Linker. Den alten mit bfd (der fetten Abstraktionsschicht von binutils) und den neuen, in C++ geschriebenen, der weniger kann, das dafuer angeblich besser: GNU gold. Den habe ich normalerweise nicht im Einsatz, weil der bei mir vor Jahren mal Probleme gemacht hat beim Firefox-Linken. Egal. Mit dem gold ist das true-Binary nur 1,3 KB gross. Ich habe also mal reingeguckt und fand in dem statischen Binary von dem bfd-ld eine PLT. PLT steht fuer Procedure Linkage Table und ist fuer die Zusammenarbeit (und Umbiegbarkeit mittels LD_PRELOAD) von Shared Libraries da. Das hat in einem statischen Binary nichts verloren. Ich habe mal einen Bug aufgemacht bei binutils.Ich stellte also auf GNU gold um, und wollte fluchs die neue glibc bauen â€” aber die baut mit ihrem neuen static-pie-Support fuer gcc 8 nicht mit gold, nur mit dem bfd-ld. *SEUFZ*Aber jetzt wo die Infrastruktur da Support fuer hat, hoffe ich mal, dass auch fuer die dietlibc static PIE nur noch eine Frage der Zeit ist, moeglichst kurzer Zeit. Das will man schon haben, besonders auf 64-bit-x86-Systemen, wo das kaum noch was kostet gegenueber Nicht-PIE.Aus Frust hab ich jetzt mal true und false in Assembler gehackt fuer x86/x64 :-)Update: Stellt sich raus: static pie mit gcc 8 funktioniert auf Anhieb, auch mit dietlibc. Cool!Update: Gestern Bug gefiled, heute Patch da. Binutils rockt!
