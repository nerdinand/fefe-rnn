[l] Ich habe hier vorhin mal OpenSSL auf 1.1 updaten wollen, und das zerschiesst einmal die gesamte Infrastruktur. Also so einmal alles. Die haben diverse interne Typen opak gemacht, und die ganze Software da draussen greift halt hemmungslos auf diese internen Datenstrukturen zu. Und man ist ja auch immer wieder ueberrascht, wie viel Software so gegen OpenSSL linkt.Die Shared Library hat eine neue Version, d.h. man muss einmal alle Software neu bauen. wget, curl, alles. curl baut gegen das neue OpenSSL, aber ist damit allein auf weiter Flur. wget musste ich patchen, mutt musste ich patchen, neon (fuer Subversion) musste ich patchen. git war gut. Der SSL-Code aus gatling geht ueberraschenderweise auch ohne Änderung. Aber sonst so? Kahlschlag.Python baut zum Beispiel nur die Module _hashlib und _ssl nicht mit. Ihr koennt euch ja ausmalen, was das alleine an Folge-Infrastrukturapokalypse nach sich zieht. Bei mir konkret geht daher gerade SCons nicht, welches das Buildsystem von serf ist, ohne das ich Subversion nicht reparieren kann.Die Perl-Module gingen auch. Aber so gefuehlt ist ueber die Haelfte der Software jetzt zerbrochen.Ich haette mir ehrlich gesagt erhofft, dass die OpenSSL-Leute da eine klitzekleine Warnung in ihren Bart saeuseln, bevor sie so eine Apokalypse lostreten.Auf der anderen Seite ist das ja auch ein schoener Impuls, mal generell von diesem OpenSSL wegzumigrieren.Update: Bei Debian hat es auch das eine oder andere Paket zerrissen.Update: Ein Leserbrief dazu:Wollte nur kurz darauf hinweisen, dass die API-Änderungen bei OpenSSL 1.1 nicht nur jede Menge inkompatibilitaeten nach sich ziehen, bei denen was laut kaputt geht (compiletime error), sondern auch API-Änderungen dabei sind, die stillschweigend security-buigs erzeugen koennen.Beispiel: Die HMAC manpage sagt:   HMAC_Init_ex() initializes or reuses a HMAC_CTX structure to use the   function evp_md and key key. Either can be NULL, in which case the   existing one will be reused.HMAC_Init_ex liefert erst seit kurzem einen Fehlerstatus zurueck - frueher hatte sie keinen Rueckgabewert und konnte nicht fehlschlagen. Daher testet auch ne Menge Software nicht auf sowas, und das wra bis vor kurzem auch korrekt.In OpenSSL 1.1 gibt es aber folgende Änderung:    /* If we are changing MD then we must have a key */    if (md != NULL && md != ctx->md && (key == NULL || len < 0))        return 0;d.h. anders als dokumentiert, kann nicht "either NULL" sein. Aber alte Software kann das nicht pruefen, und welche HMAC dann im Endeffekt berechnet wird, steht in den Sternen.Die Reaktion von OpenSSL upstream war, die Doku zu aendern.D.h. nicht nur breaked openssl die API (teilweise unnoetig) so, dass Programme nicht mehr kompilieren, nein Programme, die mal korrekt waren und jetzt immer noch kompilieren haben jetzt unter Umstaenden groessere Sicherheitsloecher.(Es gibt eine Reihe aehnlicher stiller API-Änderungen in OpenSSL 1.1)(und ja, wegmigrieren hoert sich gut an, aber es gibt haeufig keine alternative mit gleichen Funktionsumfang ohne diese Probleme - gnutls hat z.b. mindestens bis vor kurzem kein RSA-OEAP padding unterstuetzt, sondern nur das extrem anfaellige kaputte PKCS-padding).Und zu meiner Aussage, dass interne Typen opak gemacht wurden, kommentiert der Einsender noch:Das, so wuerde ich sagen, ist falsch. Erstens sind viele dieser Datentypen nicht intern, sondern man musste frueher darauf zugreifen weil es keine accessors gab und das auch so dokumentiert war, und zweitens ist das Hautproblem nicht, dass die Typen opak sind, sondern dass man frueher structs selbst allozieren musste und das jetzt nicht mehr geht, d.h. alter code nicht compiliert, auch wenn er nicht auf irgendwelche strukturen zugegriffen hat.Der Hintergrund fuer viele solche Änderungen war, dass man man structs nicht mehr auf dem Stack hat - sehr loeblich. Das wurde aber so geloest, dass man jetzt alles dynamisch ueber eine spezielle openssl-Funktion allozieren muss, die es frueher nicht gab, und code, der die structs selbst deklariert hast, schlaegt fehl, weil der Typ opak ist, auch, wenn garnicht darauf zugegriffen wird.Im Allgemeinen ist es deshalb nicht moeglich, code zu schreiben, der mit der neuen und der alten API funktioniert (also, ohne #if-massengrab).Mir ist aufgefallen, dass auch Code mit #if-Massengrab bricht mit Version 1.1. Frueher konnte man mit OPENSSL_NO_SSL2 gucken, ob die verwendete Version mit SSL2-Support kommt oder nicht. OpenSSL 1.1 hat kein SSL2 mehr, aber deklariert auch dieses Praeprozessorsymbol nicht.Update: Noch ein Leserbrief zur OpenSSL-Version:OpenSSL 1.1 Unterstuetzung fuer Python ist fertig, haengt aber noch im Codereview, weil Python Core Devs mit OpenSSL-Kenntnissen Mangelware sind. Neben mir gibt es zur Zeit nur drei weitere aktive, von denen zwei mit anderen Dingen beschaeftigt sind. Zum Glueck habe ich schon vor einem halben Jahr mit meinem Patch angefangen angefangen und einige Patches bei OpenSSL eingereicht. Andernfalls wuerden mir jetzt die Zugriffsfunktionen auf diverse struct member fehlen.https://bugs.python.org/issue26470Zwei weitere Punkte:1) Es reicht nicht, nur auf OPENSSL_VERSION_NUMBER zu pruefen. LibreSSL hat OPENSSL_VERSION_NUMBER gekapert und missbraucht das Makro fuer die eigene Versionsnummber 2.x. Man muss also immer noch zusaetzlich auf nicht-LibreSSL testen:#if (OPENSSL_VERSION_NUMBER > 0x10100000L) || !defined(LIBRESSL_VERSION_NUMBER)2) Nach sweet32 hat OpenSSL 1.0.2 nur noch einen sicheren Algorithmus fuer symmetrische Verschluesselung. ChaCha20 gibt es erst in 1.1. Ich habe mit Richard Salz vom OpenSSL Team gesprochen. Er teilt meine Sorge, trotzdem wird OpenSSL 1.0.2 LTS keine Unterstuetzung fuer ChaCha20 erhalten.https://twitter.com/ChristianHeimes/status/768434388052938756Nur falls jemand dachte, hey, dann bleib ich halt bei OpenSSL 1.0.2! Übrigens sei an der Stelle der Hinweis erlaubt, dass Version vor 1.0.1 schon laenger gar keine Updates mehr kriegen. Man sieht vereinzelt da draussen noch OpenSSL 0.9er-Versionen rumfliegen. Ganz, GANZ gruselig.Das mit Chacha20 war bei mir uebrigens auch der Ausloeser fuer den Umstieg auf 1.1. OpenSSL 1.1 hat naemlich endlich Support fuer die Dan-Bernstein-Erfindungen Chacha20 und Poly1305. Je aelter ich werde, desto weniger traue ich Krypto-Sachen, die nicht von djb kommen oder von ihm abgenickt wurden. Der Mann hat einfach zu oft Recht behalten, als alle anderen abgewunken, relativiert oder gelacht haben. Ich sehe uebrigens keinen inhaltlichen Grund, wieso man Chacha20 und Poly1305 nicht auch in 1.0.2 haben sollte, das gibt es seit Jahren fuer 1.0x-Versionen von OpenSSL als Patch, und LibreSSL hat es auch von Anfang an drin. Finde ich absolut unverstaendlich, was das OpenSSL-Team sich da leistet.
