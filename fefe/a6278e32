[l] Wenn ihr euch ein bisschen fuer Kryptographie interessiert, werdet ihr mitgekriegt haben, dass Timing-Angriffe ein Problem sind, und dass es gar nicht so einfach ist, Algorithmen so zu implementieren, dass sie keine Timing-Angriffe haben.Dan Bernstein ist auf dem Gebiet ein Vorreiter, der die elliptische Kurve Curve25519 so definiert hat, dass eine Implementation mit konstanter Laufzeit moeglich und realistisch ist. Diese Kurve hat es inzwischen in TLS geschafft, das ist ein Big Deal, wie man so schoen sagt.Und jetzt kommt raus: Visual Studio verkackt das Kompilat ueber eine implizite Laufzeitroutine zum Multiplizieren.Das heisst jetzt nicht, dass Software mit Curve25519 unsicher ist, aber das Ergebnis ist trotzdem eine echte Katastrophe. Noch eine Front mehr, die man klaeren muss. Am besten nur noch als Assembler ausliefern, alles!1!! :-)Update: OK, also bei naeherer Betrachtung stellt sich die Lage anders dar. Es geht um curve25519_donna, ein 64-bit-Port von curve25519 von djb. Das 32-bit curve25519 von djb hat das Problem nicht. curve25519_donna ist fuer 64-bit und hat dort das Problem auch nicht. Man muss also absichtlich und vorsaetzlich das falsche curve25519 auf der falschen Plattform kompilieren. Dann fuegt Visual Studio eine Routine ein, die die Multiplikation macht. Das macht gcc uebrigens genau so unter diesen Umstaenden. Ich ziehe daher meine Anschuldigung zurueck, dass VS hier was verkackt. Verkackt hat alleine der Typ, der das Advisory geschrieben hat. Ich vermute, der wollte nur mal seine 15 Minutes of Fame abholen. Scheiss Publicity-Scheiss immer.
