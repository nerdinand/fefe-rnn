[l] Beim Aufraeumen habe ich hier gerade ein Essay ueber Softwareentwicklung gefunden, das ich im November 2014 geschrieben habe. Ich kann mich gerade nicht erinnern, wofuer das war, aber es scheint nicht im Internet angekommen zu sein. Daher publiziere ich das jetzt halt mal hier:Ich habe frueh in meinem Leben mit Softwareentwicklung angefangen. Ich erinnere mich noch, wie ich in den 80er Jahren Weihnachtslieder in GW-BASIC programmiert habe, und eine sehr coole Benutzeroberflaeche gebaut habe, bei der man mit den Pfeiltasten in einem Menue herumnavigieren konnte. Auf unserem Monochrom-Bildschirm in 80x25 sah das verdammt cool aus. Viel cooler als ein Grossteil der anderen Software, die wir so im Einsatz hatten.  Damals wie heute nagte der Gedanke in mir, irgendwo koennte das irgendjemand irgendwo besser koennen als ich. Also nicht im Sinne von: Der hat mehr Zeit investiert und mehr Erfahrung und ist daher effizienter. Nein. Besser im Sinne von: Wenn der saehe, wie ich hier herumkrautern muss, um zu meinen Ergebnissen zu kommen, dann wuerde der ein lautes Lachen nur mit Muehe unterdruecken koennen.  Besonders ausgepraegt ist diese Befuerchtung immer in Verbindung mit Rock-Star-Firmen und mit Weltkonzernen, deren Software eine markfuehrende Position besetzt. Ich will das mal konkret machen. Wenn ich mich mit Google treffe und ueber Suchmaschinenprogrammierung rede, dachte ich, dann wuerden die gar nicht verstehen, wovon ich rede, weil das fuer die waere als wuerden sie sich mit einer Ameise unterhalten. Oder, so die Annahme, mit VMware koennte ich gar nicht ueber Hypervisor-Programmierung reden, weil die da ja wahrscheinlich auf einem so viel hoeheren Niveau ein Verstaendnis aufgebaut haben, dass ein Gespraech mit jemandem wie mir fuer die keinen Sinn ergeben wuerde.  Nun hat es sich ergeben, dass ich beruflich Software auf Sicherheitsluecken absuche. Ich gehe zu grossen Firmen, die zeigen mir ihren Quellcode, und ich zeige ihnen dann, wo sie Dinge falsch machen. Wie viele Menschen in dem Beruf habe ich das Impostor Syndrome, d.h. ich befuerchte regelmaessig, dass gleich jemand erkennt, dass ich gar keine Ahnung von der hier gefragten Wissens-Domain habe, und dann entfernt mich die Security aus dem Gebaeude.  Einen besonders krassen Fall von Impostor Syndrom hatte ich, als ich das erste Mal bei Microsoft Windows auditiert habe. Die hatten auch keine Ahnung, wie man sowas macht, und wen man da ranlaesst, und hatten daher ein vergleichsweise weites Netz geworfen, um potentielle Auditoren zu finden. Ich fuer meinen Teil hatte so gut wie keine Erfahrung mit Windows. Ich hielt das fuer einen Irrtum, dass die mich da hin geholt hatten. Und dann geschah das Wunder von Redmond. Ich setze mich hin, gaenzlich ohne Domain Knowledge, und fand mehr Bugs als die ganzen Leute mit Domain Knowledge.  Wie sich rausstellt, ist Domain Knowledge ueberbewertet. Und Microsoft war sich dessen staerker bewusst als ich.  Aber diese Gedankengaenge verfolgen mich bei allen Kunden. Was macht Microsofts GUI-Zeug zum Marktfuehrer?  Gibt es da irgendwas, was die besonders grossartig machen?  Wie funktioniert das Memory Management von Windows?  Hat der Hypervisor von VMware ESX im Vergleich zu Xen Roswell-Technologie im Einsatz?  Was ist eigentlich der Unterschied zwischen Oracle und MySQL?  Ist das wirklich so ein immenser Abstand?  Gelegentlich ergibt sich die Gelegenheit, mit einigen wichtigen Leuten mal ein Bierchen trinken zu gehen. Ich nutze sowas konsequent, weil es mein Weltbild enorm erweitert hat ueber die Jahre.  Einige der gewonnenen Einsichten moechte ich gerne mit euch teilen. Bei allen grossen, wichtigen Weltprodukten, bei denen ich eine Einsicht in diesen Aspekt gewinnen konnte, war das anfangs mal ein Hack von drei Leuten. Also woertlich jetzt. Drei Leute ist die typische Groesse, mit der man grossartige Produkte bauen kann. Wenn wir nur von einem Aspekt reden, der am Ende die Grossartigkeit des Produktes zementiert hat, ist es haeufig gar nur einer. Der 32-bit-Support von Windows 95 geht auf einen Typen zurueck, der das Manual von Intel auf dem Schreibtisch hatte (das konnte man sich damals fuer fast lau per Post ordern oder gratis als PDF runterladen), und der die entsprechenden Absaetze gelesen hatte, und der sich dachte, hey, das implementiere ich doch mal.  Der schoenste Spruch in diese Richtung kam von einem Datenbank-Hersteller. "Wenn wir damals Datenbank-Leute eingestellt haetten, waeren die grossartig darin gewesen, uns zu sagen, warum soundso nicht geht. Daher haben wir Nicht-Datenbank-Leute eingestellt, und die haben dann einen Weg gefunden."  In meiner Erfahrung ist der groesste Motivator in der Softwareentwicklung die Gewissheit, dass etwas substantiell besser geht. Eine schoene Anekdote dazu hoerte ich vor einer Weile. Da ging es darum, dass ein Software-Hersteller mit einer Uni zusammenarbeitete, und die hatten eine coole Idee und die auch umgesetzt im Rahmen einer Forschungsarbeit, und die blies alles aus dem Wasser, was es in dem Feld gegeben hatte. Der Hersteller hat daraufhin sein eigenes Team an einen Tisch geholt, wieder mal die fast sprichwoertlichen drei wirklich fitten Leute, und hat denen gesagt: implementiert das mal. Ihr habt das nicht erfunden, daher erwarten wir nicht, dass euer Prototyp diese Uni-Loesung outperformed, aber zumindest bis auf 50% solltet ihr rankommen. Die drei fitten Leute sind losgezogen und haben einen Prototypen gehackt, und hatten offensichtlich eine voellig falsche Vorstellung davon, welche Baseline sie erreichen muessen. Als sie ein paar Wochen/Monate gehackt hatten, und ihren Prototypen zeigten, und jemand den gegen das Uni-Ding auf gleicher Hardware benchmarkte, war der (edit: ihr Prototyp) nicht etwa 50% langsamer (edit: als die Uni-Software) sondern ueber 50% schneller.  Niemand geht los, um langsame Software zu schreiben. Aber auf dem Weg brechen viele Leute ab, weil ihnen gesagt wird, die Dinge seien "schnell genug".  Neulich scrollte eine lustige Gegenueberstellung an mir vorbei. Da hat sich einer der Vaeter von Extreme Programming vorgenommen, jetzt mal einen Sudoku-Loeser zu programmieren. Der hat mehrere Blogposts dazu gemacht. Er hatte ein festes Dogma, wie man an sowas herangeht, aber offensichtlich keine Vorstellung, wie man diese Art Problem loest. In den Blogeintraegen beschreibt er jeweils, wie er Tests programmiert und ein neues Darstellungsformat ausprobiert. Am Ende scheitert er. Die Gegenueberstellung ist ein relativ bekannter Google-Ingenieur. Der hat auch ein Blogposting geschrieben. "Ich schreibe jetzt mal einen Sudoku-Loeser". Dann hat er sich hingesetzt, beschrieben, wie man sowas macht, und einen Loeser geschrieben. Ein Blogpost.  Es ist einfach, nach sowas ueber Extreme Programming zu lachen. Aber ich glaube, dass wir ueber noch ganz andere Dinge lachen sollten. Ich glaube, dass wir einige sehr fundamentale Dinge in Sachen Softwareentwicklung schlicht noch nicht verstanden haben. Nicht nur das: Die Leute setzen systematisch Scheuklappen auf, um zu verhindern, sich damit auseinandersetzen zu muessen.  Ich habe einmal einen Code Audit einer Webplattform gemacht. Normalerweise druecken sich Auditoren um sowas, weil man befuerchten muss, dass sowas in PHP oder — schlimmer noch — Perl geschrieben ist. Das sind klassische Write-Only-Programmiersprachen. Da kann nach einer Woche auch der Typ, der es geschrieben hat, nicht mehr sagen, was dieser Code hier eigentlich tun sollte. In diesem Fall war es Perl. Wir machten drei Kreuze und fingen an. Und jetzt der Schocker: Das war wunderbar lesbarer Perl-Code. Kommentiert. Minimal. Die Firma hatte beschlossen, dass das Verbessern von bestehendem Code genau so wertvoll ist wie das Schreiben neuen Codes. Eher noch wertvoller. Wenn ein Mitarbeiter inzwischen dazugelernt hat, dass man Problem X besser so loest als wie wir das damals gemacht haben, dann geht er hin und loest es so. Unlesbarer Code wurde konsequent nicht gedulded. Fiese Konstrukte wie eval waren verpoent und nur unter strikten Ausnahmeregelungen erlaubt. Dieser Perl-Code war besser auditierbar als der durchschnittliche C++-Code. Lektion: Es liegt nicht an der Programmiersprache. Es liegt daran, dass die Firma der Lesbarkeit von Code einen Wert zuweist.  Der oben erwaehnte "war am Ende 50% schneller"-Code hat dem Management so gut gefallen, dass sie gesagt haben: Geil, shippen wir. Das war cooler Rockstar-Code, aber das war kein Produkt. Fuer eine Firma dieser Groesse und Erfahrung war es kein Problem, aus dem Codehaufen ein Produkt zu machen, das technisch den Anforderungen genuegte.  Aber wenn ich da jetzt als Auditor hinkomme und sage: Schaut mal hier, das ist eine schlechte Idee, aendert das mal lieber!  Dann sagen die mir: Koennen wir nicht; Eine Änderung hier koennte unvorhergesehene Auswirkungen ueber das ganze Produkt haben. Das Risiko koennen wir nicht eingehen.  In fast allen Grosskonzernen, in denen ich bisher Einblicke in diesen Aspekt gewinnen konnte, gibt es grosse Codemassen, deren Wartbarkeit Nahe Null ist. Weil die Firmen es nicht geschafft haben, ihre Mitarbeiter dazu zu motivieren, alten und schlechten Code Schritt fuer Schritt besser zu machen. Stattdessen gibt es ueblicherweise eine Kultur des Drucks, neue Innovationen zu programmieren.  Es ist schockierend, wie wenige Jahre ins Land streichen mussten, bis aus einem innovativen Stueck Rockstarcode ein unwartbarer Haufen Legacy geworden ist.  Zusammenfassung: Firmen ueberbewerten "wir muessen das ans Laufen bringen" und unterbewerten "wir muessen dafuer sorgen, dass das auch wartbar ist". Es werden immense Geldmengen dafuer verbrannt und Mitarbeiterberge damit verschlissen, ungepflegten alten Code weiter ungepflegt zu halten, aber noch Dinge ranzupflanschen. Ich glaube, wenn wir hier das Anreizsystem umdrehen koennten, koennten wir auf einen Schlag die Softwareentwicklung umkrempeln und Deutschland zum Weltmarktfuehrer machen. Update: Ich sollte vielleicht noch sagen, dass ich wirklich mit Google ueber Suchmaschinenprogrammierung geredet habe, und gesehen habe, wie in VMware der Hypervisor funktioniert. Nicht nur habe ich verstanden, wie die das machen, die haben das auch noch so gemacht, wie ich das auch gemacht haette (bzw. habe; einen Hypervisor habe ich noch nicht programmiert, aber eine Suchmaschine. Stellt sich raus, dass die groben Strukturen, was man so fuer Datenstrukturen verwendet und so, bei Google und mir die selben waren. Na klar haben die auch noch ein paar Tricks, die ich nicht kannte). Das liegt nicht daran, dass ich ein toller Hecht bin, sondern dass fast alle Loesungen fuer fast alle Probleme naheliegend sind, wenn man ein bisschen ueber das Problem nachdenkt. Und dann gibt es jeweils noch Hardware-Einschraenkungen, die bestimmen, welche Loesungsansaetze ueberhaupt moeglich oder zielfuehrend sind. So viel bleibt da am Ende normalerweise nicht uebrig. Ich halte es fuer ein wichtiges Ziel, dass Anwender den immer noch weit verbreiteten Respekt vor Software abbauen. Wenn man ein Haus hat, und zwei Zimmer, und man moechte gerne in der Mitte die Mauer weghaben und ein grosses Zimmer haben, dann prueft man die Statik und dann macht man die Mauer weg. Wenn man anbauen will, baut man halt an. Da ist nichts magisches dran. Bei Software ist das auch so. Wenn Google ein Haus baut, dann brauchen sie dafuer auch ein Fundament. Wenn Google ein selbstfahrendes Auto baut, dann hat das auch Raeder. Und so sieht das bei Suchalgorithmen halt auch aus.Update: Siehe auch
