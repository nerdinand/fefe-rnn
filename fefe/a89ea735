[l] Ich spiele gerade ein bisschen mit perf herum. Das ist ein Performance-Mess-Tool, das dem Linux-Kernel beiliegt. Damit kann man auf der einen Seite ganz tolle Kernel-Analysen fahren, z.B. sowas wie "wer macht hier eigentlich gerade den Disk I/O", aber man kann damit eben auch recht effizient Profiling von Userspace-Prozessen machen. Profiling ist ja grundsaetzlich eine recht schwierige Sache, denn wenn man es zu oberflaechlich macht, sind die Ergebnisse wahrscheinlich nutzlos, und wenn man es gruendlich macht, dann verfaelscht man das Laufzeitverhalten so stark, dass die Ergebnisse wahrscheinlich auch nutzlos sind.Ich habe daher eine Weile lang gar nicht Profiling mit Profiling-Tools gemacht, sondern mit Coverage-Tools, speziell gcov. Damit kann man sich am Ende zeigen lassen, welche Codezeile wie haeufig ausgefuehrt wurde. Das ist zwar nicht identisch mit der Frage, wo die Zeit verbraucht wurde, aber es hilft trotzdem beim Finden von Hotspots.perf kann jetzt Sampling-basiertes Profiling machen, mit einstellbarer Samplingrate, und kann einem dann den Code disassemblieren und die heissen Instruktionen zeigen. Ich bin noch nicht sehr weit mit dem Tool, aber mein Eindruck ist, dass das recht viel kann. Mehr jedenfalls als ich gerade benutze :-)Das Testobjekt fuer mein Rumspielen war ein Tool, das ich fuer einen Kunden geschrieben habe. Der nimmt per syslog oder stdin Logdaten entgegen und pseudonymisiert die dann. Der Schluessel fuer die Rueckzuordnung von Pseudonym und Original wird jede Stunde weggeschmissen und neu gemacht, damit man das auch einfach mitlaufen lassen kann. Ein Teil der Aufgabe des Tools ist, per Regex Usernamen zu erkennen. Dabei ruft das Tool dann regexec auf den String ab dem potentiellen Usernamen auf (und das ist in der Praxis jeder Wortanfang).Ich erzaehle das, weil mir dann auffiel, dass das Tool vergleichsweise viel Zeit im Regex-Matching verbracht hat. Nun muss man ueber regexec wissen, dass der nicht nur am Anfang des Strings matcht, sondern irgendwo in der Zeile. Aus Performancegruenden faengt die Regex fuer den Usernamen daher mit einem ^ an, d.h. "matche nur am Zeilenanfang". Meine Regex-Implementation ist an der Stelle schoen in Schichten aufgeteilt, und der Effekt war, dass regexec natuerlich nicht wusste, dass die Regex mit einem ^ beginnt und dann trotzdem fuer alle weiteren Zeichen im Inputstring zu matchen versucht hat. Diese Matchversuche schlugen natuerlich alle fehl, weil es eben nicht der Anfang des Strings war. Aber wie sich rausstellte, verbrachte das Tool in diesen sinnlosen Matches (obwohl die schon jeweils direkt abgebrochen wurden) ca. 3/4 seiner Laufzeit. Ich habe dann eine Ein-Zeilen-Änderung in regexec getan, dass der das Matchen im Rest der Zeile nicht versucht, wenn die Regex mit ^ anfaengt, und der Durchsatz des Tools hat sich vervierfacht.Die Lektion an der Sache ist aber eine Andere. perf zeigte mir vorher an, dass regexec 12% ausmachte. Es zeigte mir das zwar als teuerste Funktion an, aber die Zahlen haben bei weitem nicht die Vermutung gerechtfertigt, dass diese Änderung so viel Einsparen wuerde. Profiling-Tools sind eben schwierig :-)
