[l] Ich habe nach ein paar Zuschriften doch nochmal einen naeheren Blick auf Rust geworfen. Mein Ziel war ja, ripgrep zu kompilieren, was ein ziemlich cooles Tool ist, falls das jemand nicht kennt.Das erste, was bei Rust auffaellt: Man kann es nicht aus den Sourcen bauen. Ich moechte immer gerne vermeiden, anderer Leute Binaries auszufuehren. Das ist eine Policy bei mir. Wenn ich es nicht selbst gebaut habe, will ich es nicht haben. Es gibt nur wenige Ausnahmen, bei denen der Buildprozess zu furchtbar ist, oder so fragil, dass das selbstgebaute Binary am Ende nicht so gut funktioniert wie das "offizielle", weil die auf irgendwelche speziellen Compilerversionen setzen oder so. Die einzigen Sachen, die ich hier nicht selber baue, sind im Moment Chrome, Libreoffice (falls ich das so einmal pro Jahr mal brauche) und ripgrep. Und ripgrep wollte ich mal aendern. Ausserdem finde ich Rust von den Konzepten her spannend und will mal damit rumspielen.Erste Erkenntnis: Die neueren Versionen von openssl-rust koennen OpenSSL 1.1. Allerdings kann man Rust nicht aus den Sourcen bauen, ohne schon eine Version von Rust zu haben. Das finde ich sehr schade. Das ist ein Spannungsfeld, das viele Programmiersprachen betrifft. Programmiersprachen haben Angst, erst ernst genommen zu werden, wenn sie self-hosting sind. Die Download-Seite von Rust will einem erstmal Binaerpakete aufdruecken, was ich immer ein schlechtes Zeichen finde. Binaerpakete ist der schlechte Kompromiss fuer Leute, die zu doof sind, aus den Sourcen zu bauen. Und die sind bei Rust nicht Zielgruppe. Dafuer ist die Lernkurve zu steil bei Rust.Aber wenn man runterscrollt, kriegt man auch die Quellen. Und wenn man da configure und make aufruft, dann … zieht der ungefragt ein Binaerpaket einer aelteren Rust-Version, installiert das, und baut dann damit. Das vereint die Nachteile von "aus Binaerpaket installieren" mit der Wartezeit von "aus Quellen bauen" und weicht etwaigen Vorteilen weitraeumig aus. Voellig gaga. Aber es gibt eine configure-Option, dass man das installierte Rust haben will.Aus meiner Sicht ist der perfekte Kompromiss, was Ocaml macht. Da kommen die Quellen mit einem kleinen C-Bootstrap-Interpreter, und der baut dann den Compiler, und der baut sich dann nochmal selber. So muss das sein. Ist es aber bei Rust leider nicht. Bei Go auch nicht mehr, uebrigens.Anyway. Wenn man das ueber sich ergehen laesst und Rust aus den Sourcen baut, dann kriegt man eine Version ohne cargo. cargo ist das Packaging-Tool von Rust. Ohne cargo kann man nichts bauen. Insbesondere kann man nicht cargo ohne cargo bauen. Und da muss ich sagen: WTF? Selbst GNU make kann man ohne make bauen! Das ist ja wohl absolut offensichtlich, dass man solche Henne-Ei-Probleme vermeiden will!?Insgesamt muss ich also meine Kritik zurueckziehen, dass Rust immer noch nicht mit OpenSSL 1.1 klarkommt. Tut es, nur halt anscheinend nicht in der stable-Version. Aber diese cargo-Situation finde ich ja noch schlimmer als die OpenSSL-Situation war. Meine Guete, liebe Rust-Leute! Bin ich ernsthaft der erste, der ueber das Bootstrapping nachdenkt?!Oh ach ja, ripgrep. ripgrep kann man nicht mit der Stable-Version von Rust kompilieren. Und auch nicht mit der Beta-Version. Das braucht die Bleeding-Edge-Version.Nun ist Rust eine relativ frische Sprache und sie haben daher eine Familienpackung Verstaendnis fuer so Kinderkrankheiten verdient. Aber dann nennt euren Scheiss halt nicht Version 1.irgendwas sondern 0.irgendwas.Update: Wie sich rausstellt, laesst sich ripgrep doch mit aelteren Rust-Versionen kompilieren, allerdings dann ohne SIMD-Support. Wenn ich ripgrep ohne SIMD-Support haben wollen wuerde, koennte ich auch grep -r benutzen oder silver surfer. Was ich versucht habe, um ripgrep zu bauen: git clone + cd ripgrep + ./compile. Mir erklaert jetzt jemand per Mail, dass das gar nicht der offizielle Build-Weg ist unter Rust. Das hat sich mir als Rust-Neuling so nicht erschlossen. Und es wirft die Frage auf, wieso der Autor von ripgrep dann ein configure-Skript beliegen muss und das dann auch noch was anderes tut als der Standard-Buildweg. Ist der Standard-Weg kaputt und man kann die zusaetzlichen Flags, die er da benoetigt, nicht einstellen?Update: Ein paar Leute fragen jetzt rhetorisch, wie ich denn meinen C-Compiler gebootstrappt habe. Das Argument koennte man gelten lassen, wenn es von Rust aus moeglich waere, einen C-Compiler zu bootstrappen. Ist es aber nicht. Aber mit einem C-Compiler kann man diverse andere Sprachen bootstrappen, u.a. Go, Lisp, Forth, Scheme, Ocaml, C++, Javascript, Java, .... Aber um kurz die rhetorische Frage zu beantworten: Meinen C-Compiler habe ich cross-compiled. :-)Update: Bei Ocaml ist es auch nicht so rosig, wie ich es geschildert habe. Der in C geschriebene Interpreter ist bloss ein Bytecode-Interpreter, und ein vor-gebauter Bytecode liegt dann halt binaer bei. Ist auch nicht ideal. Das ist halt auch ein schwieriges Problem. Ich frage mich halt, ob man bei sowas wie Rust nicht trennen kann. Mein Verstaendnis war, dass die Sprache Rust schon ziemlich final ist und die Dynamik eher in der Laufzeitumgebung und den Libraries ist. Dann koennte man ja beispielsweise einen Minimal-Interpreter oder Nach-C-Übersetzer bauen, der sich die komplizierten Dinge wie Borrow-Checker, Solver und Optimizer spart.
