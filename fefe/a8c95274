[l] Oje, Linus hat mal wieder auf LKML herumgerantet, diesmal ging es um Integer Overflow Checks. Hier ist der Code vorher:mtu -= hlen + sizeof(struct frag_hdr);Und hier ist, was der neue Code tut:if (overflow_usub(mtu, hlen + sizeof(struct frag_hdr), &mtu) || mtu <= 7)  goto fail_toobig;Als erstes faellt auf, dass der Code nicht das selbe tut. Nehmen wir mal an, dass overflow_usub zwei unsigned ints subtrahiert und dann meckert, wenn das Ergebnis negativ wuerde. Dann faengt dieser Code nicht nur den Overflow ab, sondern er prueft auch, dass mtu danach mindestens 8 ist. Allerdings prueft der Code nicht, ob hlen + sizeof(struct frag_hdr) bereits ueberlaeuft. Und das ist an sich schon ein Problem. Komme ich gleich drauf.Linus' Kritik ist im Wesentlichen: Ist schlecht lesbar, ist ineffizient und immer noch unsicher.Ich glaube, dass er bei allen drei Kritikpunkten irrt. Hier ist Linus' Gegenvorschlag, wie der Code lesbarer aussehen koennte:if (mtu < hlen + sizeof(struct frag_hdr) + 8)  goto fail_toobig;mtu -= hlen + sizeof(struct frag_hdr);Ich finde das lesbar. Aber ich mache das auch beruflich, in Code nach Integer Overflows zu checken. Viele Programmierer werden sich das angucken und gar nicht verstehen, was hier das Problem ist, das da geprueft wird. Wenn das Label nicht "fail_toobig" hiesse, waere gar nicht klar, was hier eigentlich geprueft werden soll. Linus' Version ist daher meiner Meinung nach nicht lesbarer. Und sie hat eine gewisse Fragilitaet. Wenn hlen ein size_t ist und beliebig gross sein kann, schlaegt der Test fehl. Wird hier nicht so sein, so gut wie niemand hat 64-bit Headerlaengen in der Praxis in seinen Protokollen. Aber es gibt Ausnahmen. Gut, nehmen wir mal an, hlen ist ein unsigned short (oder wir sind auf einer 64-bit-Plattform und hlen ist ein unsigned int). Wenn der Compiler das evaluiert, gibt es keinen Overflow, wenn in der Reihenfolge, in der der Compiler das evaluiert, zuerst eine Addition mit dem sizeof-Wert gemacht wird. Dann promoted C den Typ des Ergebnisses zu size_t, das ist an der Stelle gross genug und hat keine Overflow-Probleme. Aber was wenn ein weniger fitter Programmierer so einen Test zu bauen versucht und die Reihenfolge verkackt?if (mtu < hlen + 8 + sizeof(struct frag_hdr))Wenn das sorum dasteht, und hlen gross genug reinkommt, und der Compiler hlen+8 zuerst evaluiert, dann kann der Teil ueberlaufen und wir addieren auf das abgeschnittene Ergebnis das sizeof drauf und das ist dann size_t, aber hatte schon einen Überlauf. Meines Wissens gibt es keinen Compiler, der Linus' Ausdruck boeswillig umsortieren wuerde. Aber der Standard garantiert keine Reihenfolge der Auswertung. Der Compiler duerfte das meines Wissens machen. Und wuerde damit Linus' Check kaputtmachen.Die Compiler-Builtins, die hinter diesem Makro stehen, sind hier beschrieben. gcc hat das urspruenglich von clang geklaut, aber hat es an einer wichtigen Stelle besser und damit ueberhaupt erst ordentlich benutzbar gemacht. Bei clang musste man anfaenglich je nach Datentyp ein anderes Builtin aufrufen, und das ist natuerlich auch voll fuer den Arsch, denn diese Subtilitaeten sind ja gerade die Fehlerquelle, die wir durch sowas ausschliessen wollen. Heute gibt es auch bei clang __builtin_add_overflow, und das sieht in Beispielcode so aus:#include <stdlib.h>int s(int a,int b) {  int c;if (__builtin_add_overflow(a,b,&c))    exit(1);  return c;}Der Compiler erzeugt fuer diese Funktion diesen Code:s:        movl    %edi, %eax        addl    %esi, %eax        jo      .L9        rep ret.L9:[… Error handling …]Aus meiner Sicht ist dieser Code an dieser Stelle optimal. Ich wuesste jedenfalls nicht, wie man das besser machen koennte. Das "rep ret" ist uebrigens ein Fix fuer einen Bug in einem der ersten 64-bit Athlons damals. Wusstet ihr nicht? Ja, so ist das, die Compiler sind ziemlich smart heutzutage. Smarter als die meisten Programmierer :-)Was ich damit sagen will: Nein, Linus, die Builtins generieren keinen schlechten Code. Wenn der Code an der Stelle mehr tut als einen Conditional Jump einfuegen, der im Normalfall nicht genommen wird (und damit fast kostenlos ist), dann war der Compiler moeglicherweise smarter als du an der Stelle und hat erkannt, dass die beiden reinkommenden Typen nicht gleich breit waren und einen zusaetzlichen Check eingefuegt, ob ein Zwischenergebnis abgeschnitten wird.So. Also nochmal zu den drei Argumenten. Unlesbar bestreite ich, weil bei dem Makro explizit und offensichtlich ist, was der Programmierer erreichen will. Das ist immer besser als eine Packung Ultrasmart-Bitpfriemel-Kram, bei dem der Auditor zehn Minuten braucht, bis er versteht, was hier der Trick und das gewuenschte Ergebnis ist, und ob der Weg dahin ueberhaupt korrekt ist.Das zweite Argument war Ineffizienz. Das habe ich gerade widerlegt.Das dritte Argument war Unsicherheit. Nun, Linus, das mag jetzt schmerzen, aber der Code ist sicherer als der vorgeschlagene Ersatzcode :-)Daher, liebe Leser: Wenn ihr C programmiert, und euch fragt, ob ihr lieber die Builtins verwenden sollt oder auch alte Compiler unterstuetzten, dann NEHMT DIE BUILTINS. Ich bin sogar dafuer, gar keinen Fallback-Pfad fuer alte gcc-Versionen anzubieten. Wer neuen Code mit alten Compilern uebersetzt, hat verdient, dass das kracht. Diese ganze Debian-Antiquitaetenhaendler-Fraktion braucht mal ein paar Warnschuesse vor den Bug. Das ist ja schlimmer als Windows XP!Wenn ihr ueberlegt, ob ihr lieber selber Overflow-Checks hackt oder lieber die Builtins nehmen sollt, NEHMT DIE BUILTINS.Wenn ihr ueberlegt, ob ihr Overflow-Checks braucht oder nicht, dann NEHMT DIE BUILTINS. Die Checks kosten so gut wie nichts. Nein, wirklich. Da muss man sich anstrengen, um das ueberhaupt mit geschickten Mikrobenchmarks messen zu koennen. Und wenn der Check an der Stelle ueberfluessig waere, und gcc das erkennen kann, dann fliegen auch die eh schon fast kostenlosen Checks noch raus.Es gibt keine Ausreden. Nehmt die Builtins. Jedes einzelne Mal. Insbesondere, wenn es um Multiplikation geht. Das verkacken so viele Programmierer da draussen, dass ich das naheliegende Trinkspiel aufgeben musste. Probiert es gar nicht erst. Nehmt die Builtins. Und ich empfehle euch das, obwohl mein Lebensunterhalt davon abhaengt, dass es Leute gibt, die nicht die Builtins benutzen.Update: Wie sich rausstellt, sagt der C-Standard doch was zur Assoziativitaet von arithmetischen Operatoren. Der Compiler darf sich also nicht aussuchen, in welcher Reihenfolge er was addiert.
