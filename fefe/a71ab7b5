[l] Bug des Tages: Der Intel-Compiler unter Linux.Der Intel Compiler kommt mit neueren glibc Versionen nicht zurecht, da diese einen Bug im Intel Compiler exponieren, der zu "unpredictable system behaviour" fuehrt. Bei uns auf dem HPC Cluster hat sich das so manifestiert, dass unsere Benutzer nach dem Update von CentOS 7.3 auf CentOS 7.4 (dieses Update der glibc exponiert den Intel Bug) bei Simulationen (z.B. mit Kommerziellen "Finite Element" Applikationen wie ANSYS CFX, 3DS Abaqus etc.) falsche Resultate bekamen:Simulationen die vor dem Update konvergierten tun dies nicht mehrSimulationen brechen ab, weil an verschiedenen Stellen NaN's raus kommen wo das nicht sein sollte.Bei Simulationen kommen andere Zahlen raus als vor dem UpdateDer Bug betrifft potenziell alle mit Intel (Versionen aelter als 17.0 Update 5) kompilierten Binaries und Bibliotheken auf Systemen mit Intel CPUs, welche AVX unterstuetzen.Intel ist der Fehler seit Maerz 2017 bekannt.Die zugehoerigen Bug reports: Redhat, glibc.Und weil das so grandios ist, kommt hier die technische Erklaerung, was da vor sich geht:According to x86-64 psABI, xmm0-xmm7 can be used to pass functionparameters.  But ICC also uses xmm8-xmm15 to pass function parameterswhich violates x86-64 psABI.  As a workaround, you can set environmentvariable LD_BIND_NOW=1 by# export LD_BIND_NOW=1Keine weiteren Fragen, Euer Ehren!Update: Ich sollte vielleicht mal erklaeren, was hier vor sich geht. Das ABI ist die Spezifikation dafuer, wie man auf einer gegebenen Plattform auf Maschinencode-Ebene Argumente an Funktionen uebergibt, und welche Registerinhalte Funktionen ueberschreiben duerfen, welche sie sichern muessen. Intel hat die Spec gesehen und gesagt "Hold my beer! Die Register dahinten benutzt keiner! Die nehm ich mal!" Das ABI hat aber ganz klar gesagt, dass die eben nicht frei sind.Das Szenario hier ist: Der Compiler generiert Code fuer einen Funktionsaufruf. Nun koennte man sagen, hey, wenn der Intel-Compiler beide Seiten erzeugt hat, dann kann ja nichts schiefgehen. Aber es kann halt doch was schiefgehen. Wenn man ein dynamisch gelinktes Binary hat, dann geht der Funktionsaufruf eben nicht zur Funktion, sondern zum Wert in einer Tabelle. Die Eintraege in der Tabelle zeigen initial auf ein Stueck Code in der glibc, der dann die Adresse fuer das Symbol herausfindet und in die Tabelle eintraegt und dann dahin springt. Die Idee ist, dass so eine Tabelle mehrere Zehntausend Eintraege enthalten kann bei grossen Binaries, und wenn man die alle beim Start von dem Binary aufloest, dann ergibt das eine spuerbare Verzoegerung. Denkt hier mal an sowas wie Firefox oder clang von LLVM. Daher loest man erst beim ersten Aufruf auf. Mit LD_BIND_NOW=1 kann man der glibc sagen, dass er bitte alles am Anfang aufloesen soll, nicht erst spaeter.Was hier also passiert ist, ist dass der glibc-Code, der die Symbolaufloesung macht, sich an das ABI gehalten hat und die u.a. fuer ihn reservierte Register benutzt hat. Und da hatte der Intel-Compiler aber Argumente reingetan. Die hat der Code zum Symbolaufloesen dann mit Muell ueberschrieben. Die glibc waescht hier ihre Haende in Unschuld (und ich haette nicht gedacht, dass ich DAS nochmal sagen wuerde). (Danke, Samuel)
